<!DOCTYPE html>



 <html class="no-js"> 
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="author" content="Jerod Santo">
    <meta property="og:site_name" content="Jerod Santo">
    
    <meta name="description" content="Regular expressions are great for matching many patterns, but they are usually not ideal when matching nested structures (recursive matching).
Most regular expression engines can handle a known level of recursion and some engines can even handle arbitrary recursion, but the required expressions are often quite complex, which makes them difficult to read, modify, and extend.
Instead, you can use this simple algorithm to identify nested substrings.
The Algorithm
Traverse the string&rsquo;s characters one by one, applying the following logic:">
    <meta property="st:title" content="An Algorithm to Reliably Identify Nested Substrings">
    <meta property="og:title" content="An Algorithm to Reliably Identify Nested Substrings">
    <meta property="og:description" content="Regular expressions are great for matching many patterns, but they are usually not ideal when matching nested structures (recursive matching).
Most regular expression engines can handle a known level of recursion and some engines can even handle arbitrary recursion, but the required expressions are often quite complex, which makes them difficult to read, modify, and extend.
Instead, you can use this simple algorithm to identify nested substrings.
The Algorithm
Traverse the string&rsquo;s characters one by one, applying the following logic:">
    <meta property="og:type" content="article">
    
    <meta property="og:image" content="/icon.png">
    
    
    <title>
      An Algorithm to Reliably Identify Nested Substrings | Jerod Santo
    </title>

    <link rel="icon" href="/icon.png" sizes="256x256" type="image/png">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" type="text/css" media="all" href="/styles.css">
    <script>
       
      window.grunticon=function(e){if(e&&3===e.length){var t=window,n=!(!t.document.createElementNS||!t.document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||window.opera&&-1===navigator.userAgent.indexOf("Chrome")),o=function(o){var r=t.document.createElement("link"),a=t.document.getElementsByTagName("script")[0];r.rel="stylesheet",r.href=e[o&&n?0:o?1:2],a.parentNode.insertBefore(r,a)},r=new t.Image;r.onerror=function(){o(!1)},r.onload=function(){o(1===r.width&&1===r.height)},r.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw=="}};
      grunticon(["/icons/icons.data.svg.css", "/icons/icons.data.png.css", "/icons/icons.fallback.css"]);
    </script>

    <link href='//fonts.googleapis.com/css?family=Roboto+Condensed:400italic,400' rel='stylesheet' type='text/css'>
    <script src="//use.typekit.net/ozg5mvx.js"></script>
    <script>try{Typekit.load();}catch(e){}</script>
    <script src="/js/modernizr-custom.js"></script>

    

    <link rel="alternate" type="application/atom+xml" href="/index.xml" />
  </head>
  <body class="">
    
    <div class="main-header">
      <h1>
        <a href="/" title="Home">
          <span class="big-dot">&middot;</span> Jerod Santo <span class="big-dot">&middot;</span>
        </a>
      </h1>
      <a href="javascript:void(0);" title="Moar" class="main-header-more">+</a>
      <a href="/archives/" title="View Blog Archives" class="main-header-archive">Archives</a>
      <a href="mailto:jerod.santo@gmail.com" title="Contact Jerod" class="main-header-contact">Contact</a>
      <a href="/search/" title="Search the site" class="main-header-search">Search</a>
    </div>
    

    
<article class="post">
  <header class="post-header">
    <h1>An Algorithm to Reliably Identify Nested Substrings</h1>
    
    <p class="post-date">
      November 12, 2012
    </p>
  </header>

  

  <div class="post-content">
    <p>Regular expressions are great for matching many patterns, but they are usually not ideal when matching nested structures (recursive matching).</p>
<p><em>Most</em> regular expression engines can handle a known level of recursion and <em>some</em> engines can even handle arbitrary recursion, but the required expressions are often quite complex, which makes them difficult to read, modify, and extend.</p>
<p>Instead, you can use this simple algorithm to identify nested substrings.</p>
<h2 id="the-algorithm">The Algorithm</h2>
<p>Traverse the string&rsquo;s characters one by one, applying the following logic:</p>
<ul>
<li>When a <strong>start delimiter</strong> is met and there is not already a <strong>start index</strong>, mark its index and increment the <strong>depth counter</strong></li>
<li>When a <strong>start delimiter</strong> is met and there is already a <strong>start index</strong>, just increment the <strong>depth counter</strong></li>
<li>When an <strong>end delimiter</strong> is met and the <strong>start index</strong> isn&rsquo;t marked, do nothing</li>
<li>When an <strong>end delimiter</strong> is met and the <strong>start index</strong> is marked, decrement the <strong>depth counter</strong></li>
<li>When an <strong>end delimiter</strong> is met, the <strong>start index</strong> is marked, and the <strong>depth counter</strong> is 0, store current <strong>start index</strong> and <strong>end index</strong>, then reset both indexes</li>
</ul>
<p>The result is a series of start/end position tuples which are used to identify and return the nested substrings. How about an example?</p>
<h2 id="an-example">An Example</h2>
<p>Let&rsquo;s say that you want to take a string of text and remove any asides in it. An aside is defined as any text inside parantheses. Asides can be nested inside one another, but the goal is to remove them all.</p>
<p>So, this string of text:</p>
<blockquote>
<p>ohai there (friend), do we (that&rsquo;s the royal we (duh!)) know what&rsquo;s up?</p>
</blockquote>
<p>Would need to match:</p>
<blockquote>
<p>(friend)</p>
</blockquote>
<p>and</p>
<blockquote>
<p>(that&rsquo;s the royal we (duh!))</p>
</blockquote>
<p>Additionally, this string of text:</p>
<blockquote>
<p>Well, 1) we should go to the store (grocery (not Hy-Vee)), and 2) we should buy stuff</p>
</blockquote>
<p>Would need to match:</p>
<blockquote>
<p>(grocery (not Hy-Vee))</p>
</blockquote>
<p>Finally, this string of text:</p>
<blockquote>
<p>This is, literally, an improper use of &ldquo;literally&rdquo;. Or is it?</p>
</blockquote>
<p>Would need to not match anything. Let&rsquo;s implement the algorithm in Ruby. We&rsquo;ll call the method <code>asides</code>.</p>
<h2 id="a-ruby-implementation">A Ruby Implementation</h2>
<p>First, we turn the spec above into executable RSpec code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>describe <span style="color:#0a3069">&#34;asides&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0a3069">&#34;matches multiple, nested substrings&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>    matches <span style="color:#0550ae">=</span> asides <span style="color:#0a3069">&#34;ohai there (friend), do we (that&#39;s the royal we (duh!)) know what&#39;s up?&#34;</span>
</span></span><span style="display:flex;"><span>    matches<span style="color:#0550ae">.</span>first<span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> <span style="color:#0a3069">&#34;(friend)&#34;</span>
</span></span><span style="display:flex;"><span>    matches<span style="color:#0550ae">.</span>last<span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> <span style="color:#0a3069">&#34;(that&#39;s the royal we (duh!))&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0a3069">&#34;does not match partial substrings&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>    matches <span style="color:#0550ae">=</span> asides <span style="color:#0a3069">&#34;Well, 1) we should go to the store (grocery (not Hy-Vee)), and 2) we should buy stuff&#34;</span>
</span></span><span style="display:flex;"><span>    matches<span style="color:#0550ae">.</span>first<span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> <span style="color:#0a3069">&#34;(grocery (not Hy-Vee))&#34;</span>
</span></span><span style="display:flex;"><span>    matches<span style="color:#0550ae">.</span>size<span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> <span style="color:#0550ae">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0a3069">&#34;has no matches when there are no substrings&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>    matches <span style="color:#0550ae">=</span> asides <span style="color:#0a3069">&#34;This is, literally, an improper use of &#39;literally&#39;. Or is it?&#34;</span>
</span></span><span style="display:flex;"><span>    matches<span style="color:#0550ae">.</span>size<span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> <span style="color:#0550ae">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">end</span>
</span></span></code></pre></div><p>Next, we write the <code>asides</code> method, which implements the algorithm above, to make all three of these tests pass:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#cf222e">def</span> <span style="color:#6639ba">asides</span><span style="color:#1f2328">(</span>text<span style="color:#1f2328">,</span> start_delimiter<span style="color:#0550ae">=</span><span style="color:#0a3069">&#34;(&#34;</span><span style="color:#1f2328">,</span> end_delimiter<span style="color:#0550ae">=</span><span style="color:#0a3069">&#34;)&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>  depth <span style="color:#0550ae">=</span> index <span style="color:#0550ae">=</span> <span style="color:#0550ae">0</span>
</span></span><span style="display:flex;"><span>  asides <span style="color:#0550ae">=</span> <span style="color:#0550ae">[]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">while</span> index <span style="color:#0550ae">&lt;</span> text<span style="color:#0550ae">.</span>length
</span></span><span style="display:flex;"><span>    char <span style="color:#0550ae">=</span> text<span style="color:#0550ae">[</span>index<span style="color:#0550ae">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#cf222e">if</span> char <span style="color:#0550ae">==</span> start_delimiter
</span></span><span style="display:flex;"><span>      start <span style="color:#0550ae">||=</span> index
</span></span><span style="display:flex;"><span>      depth <span style="color:#0550ae">+=</span> <span style="color:#0550ae">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#cf222e">elsif</span> char <span style="color:#0550ae">==</span> end_delimiter <span style="color:#0550ae">&amp;&amp;</span> start
</span></span><span style="display:flex;"><span>      depth <span style="color:#0550ae">-=</span> <span style="color:#0550ae">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#cf222e">if</span> depth <span style="color:#0550ae">==</span> <span style="color:#0550ae">0</span>
</span></span><span style="display:flex;"><span>        asides <span style="color:#0550ae">&lt;&lt;</span> text<span style="color:#0550ae">[</span>start<span style="color:#0550ae">..</span>index<span style="color:#0550ae">]</span>
</span></span><span style="display:flex;"><span>        start <span style="color:#0550ae">=</span> <span style="color:#cf222e">nil</span>
</span></span><span style="display:flex;"><span>      <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    index <span style="color:#0550ae">+=</span> <span style="color:#0550ae">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  asides
</span></span><span style="display:flex;"><span><span style="color:#cf222e">end</span>
</span></span></code></pre></div><h2 id="using-the-method">Using The Method</h2>
<p>Now that the <code>asides</code> method is returning a list of substrings, we just need to loop over them and remove them from the original text. This will achieve our original goal of removing all asides. Let&rsquo;s spec and write a <code>sans_asides</code> method to do just that:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>describe <span style="color:#0a3069">&#34;sans_asides&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>  let<span style="color:#1f2328">(</span><span style="color:#032f62">:desired_text</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">{</span> <span style="color:#0a3069">&#34;well isn&#39;t that neat?&#34;</span> <span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0a3069">&#34;creates a string with all asides removed from the original&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>    text <span style="color:#0550ae">=</span> <span style="color:#0a3069">&#34;well (now) isn&#39;t that neat (if I do say so myself (and I do))?&#34;</span>
</span></span><span style="display:flex;"><span>    sans_asides<span style="color:#1f2328">(</span>text<span style="color:#1f2328">)</span><span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> desired_text
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it <span style="color:#0a3069">&#34;creates an identical string when original string has no asides&#34;</span> <span style="color:#cf222e">do</span>
</span></span><span style="display:flex;"><span>    sans_asides<span style="color:#1f2328">(</span>desired_text<span style="color:#1f2328">)</span><span style="color:#0550ae">.</span>should <span style="color:#0550ae">==</span> desired_text
</span></span><span style="display:flex;"><span>  <span style="color:#cf222e">end</span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">end</span>
</span></span></code></pre></div><p>And the implementation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#cf222e">def</span> <span style="color:#6639ba">sans_asides</span><span style="color:#1f2328">(</span>text<span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>  asides<span style="color:#1f2328">(</span>text<span style="color:#1f2328">)</span><span style="color:#0550ae">.</span>each <span style="color:#1f2328">{</span> <span style="color:#0550ae">|</span>aside<span style="color:#0550ae">|</span> text<span style="color:#0550ae">.</span>gsub! <span style="color:#0a3069">/\s?</span><span style="color:#0a3069">#{</span><span style="color:#0550ae">Regexp</span><span style="color:#0550ae">.</span>quote<span style="color:#1f2328">(</span>aside<span style="color:#1f2328">)</span><span style="color:#0a3069">}</span><span style="color:#0a3069">/</span><span style="color:#1f2328">,</span> <span style="color:#0a3069">&#34;&#34;</span> <span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>  text
</span></span><span style="display:flex;"><span><span style="color:#cf222e">end</span>
</span></span></code></pre></div><p>Two things to note in this code:</p>
<ol>
<li>We&rsquo;re using the returned asides in a regular expression to also remove any leading whitespaces</li>
<li>We use <code>Regexp.quote</code> so that any special characters in the aside are properly escaped</li>
</ol>
<h2 id="other-solutions">Other Solutions</h2>
<p>I think this mehod of nested substring identification is pretty solid. It is relatively easy to read and it decouples the identification step from the manipulation step.</p>
<p>But surely there are other (better?) ways to skin this cat. How would you tackle it?</p>

  </div>

  <ul class="post-share-buttons">
    <li class="service_twitter post-share-1">
      <a class="icon-twitter" href="https://twitter.com/intent/tweet?url=http%3a%2f%2flocalhost%3a1313%2f2012%2f11%2fan-algorithm-to-reliably-identify-nested-substrings%2f&via=jerodsanto&text=An%20Algorithm%20to%20Reliably%20Identify%20Nested%20Substrings" title="Tweet">
        <span>Tweet</span>
      </a>
    </li>
    <li class="service_rss post-share-2">
      <a class="icon-rss" href="/index.xml" title="Subscribe to the feed!">
        <span>RSS</span>
      </a>
    </li>
    <li class="service_hackernews post-share-3">
      <a class="icon-hackernews" href="http://news.ycombinator.com/submitlink?u=http%3a%2f%2flocalhost%3a1313%2f2012%2f11%2fan-algorithm-to-reliably-identify-nested-substrings%2f&t=An%20Algorithm%20to%20Reliably%20Identify%20Nested%20Substrings" title="Post to Hacker News">
        <span>Hacker News</span>
      </a>
    </li>
    <li class="service_instapaper post-share-4">
      <a class="icon-instapaper" href="http://www.instapaper.com/hello2?url=http%3a%2f%2flocalhost%3a1313%2f2012%2f11%2fan-algorithm-to-reliably-identify-nested-substrings%2f&title=An%20Algorithm%20to%20Reliably%20Identify%20Nested%20Substrings" title="Read later">
        <span>Instapaper</span>
      </a>
    </li>
  </ul>

  
  

  <div id="disqus_thread"></div>
  <script>
    var disqus_url   = "http:\/\/localhost:1313\/2012\/11\/an-algorithm-to-reliably-identify-nested-substrings\/";
    var disqus_title = "An Algorithm to Reliably Identify Nested Substrings";
    (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://blogt0sk1.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script src="//platform.twitter.com/widgets.js"></script>
</article>


    <footer class="main-footer">
  <p>
    Copyright &copy; 2008&mdash;2025 Jerod Santo
  </p>
</footer>

    
    <script src="/js/compiled.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-3287978-16', 'auto');
      ga('send', 'pageview');
    </script>
    
  </body>
</html>